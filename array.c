#include<stdio.h>
#include<string.h>
// 一、一维数组：
// 1、数组的创建：
// int arr[10];             int --- 存放整型；   arr --- 数组名；   [10] --- 这里的10为数组的大小，里面放多少个元素，[]里面必须写常量表达式，不能是变量。

// 2、数组的初始化：在数组的创建同时给数组的内容一些合理的值。
/* int main()
{
    int arr[5] = {1,2,3};           //前面给了五个元素的空间，这里赋值只给了三个，后面两个值会默认初始化为0 --- 不完全初始化。
    char arr2[5] = {'a','b','c'};     //也是不完全初始化,后面两个值默认初始化为0。
    char arr3[5] = "abc";            //存放字符串的时候最后一位有一个\0。
    char arr4[] = "abcdef";         //会根据初始化的值来确定数组的大小。
    printf("%d",sizeof(arr4));      //sizeof(arr4)计算arr4所占空间的大小，单位为字节，属于操作符。
    printf("%d",strlen(arr4));      //strlen(arr4)求字符串长度：'\0'之前有多少个字符，是库函数，引用的时候需要头文件。
    return 0;
} */

// 3、一维数组的使用。（内存的存放是连续的）
// 操作符：[]：下标引用操作符。
// 例：打印出数组arr1[]里面的元素，每次只能打印一个。
/* int main()
{
    int arr[5] = {1,2,3,4,5};
    int i = 0;
    int sz = sizeof(arr)/sizeof(arr[0]);            //求数组的长度（之前写过）。
    for(i = 0; i < sz; i++)
    {
        printf("%d ",arr[i]);                       //用下标访问数组中的元素，下标起始数为0。
    }
    return 0;
} */

// 二、二维数组： --- 可以想象成为n行的一维数组。
// 1、二维数组的创建和初始化：跟一维数组类似。
/* int main()
{
    int arr[3][4];          //[3]：3行； [4]：4列；
    int arr2[3][4] = {1,2,3,4};      //表示第一行：1、2、3、4；后面的3行默认初始值为0；
    int arr3[3][4] = {{1,2},{3,4}};  //表示第一行：1、2、0、0；第二行：3，4，0，0；后面两行默认初始值为0。
    int arr4[][4] = {{1,2},{3,4}};   //表示第一行：1、2、0、0；第二行：3，4，0，0；后面两行默认初始值为0。--- 这里行号可以省略，列号不能省，不然会报错。
    printf("%d",arr2[0][0]);
    return 0;
} */

// 2、二维数组的使用：（内存的存放也是连续的）
// 例：打印出数组arr1[]里面的元素。
/* int main()
{
    int arr3[3][4] = {{1,2},{3,4}};
    int i = 0;
    for ( i = 0; i < 3; i++)
    {
        int j = 0;
        for ( j = 0; j < 4; j++)
        {
            printf("%d ",arr3[i][j]);
        }
        printf("\n");
    }
    return 0;
} */

// 三、数组作为函数参数：
// 例如：实现一个冒泡排序函数将一个整形数组排序（从小到大）。
// 冒泡排序：先把第1个数与后面的数一一比较，如果前者大于后者（要满足从小到大），就将两数交换，直到这个数不再大于后面的数/大于到后面没有数为止，此时，完成第一个数的冒泡排序，然后面的所有数都按次方式进行。
/* void bubbling(int arr[], int sz)
{
    int i = 0;
    for( i = 0 ; i < sz - 1 ; i++)          //满足我数组里面前（sz - 1）个元素能够排序，因为这里排完之后，最后一个元素的位置默认就确定了。
    {
        int j = 0;
        int k = 1;                          //这个的设置目的是：防止在循环次数结束之前已经按顺序排列时，循环不会停止，还会继续进行下去，避免浪费多余的时间。
        for(j = 0 ; j < sz - 1 - i; j++)          //减少我不必要比较的次数，因为每次排序的时候总会每个元素找到自己最终排序的位置，那么就会少比较一次（就像我10个元素，只需要比九次就可以确定所有元素的位置）。
        {
            if(arr[j] < arr[j+1])               //如果前者大于后者，交换两个数的位置。
            {
                int tem = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tem;
                k = 0;                      //如果没有完成顺序排列，那么，不好意思，循环继续，若完成，那么就该走人了。
            }
        }
        if(k == 1)
        {
            break;
        }
    }
}

int main()
{
    int arr[] = {2,1,3,5,4,6,8,9,7,0};          //10个元素。
    int sz = sizeof(arr)/sizeof(arr[0]);        //在函数外求出元素个数，因为数组传参的时候只会吧第一个元素的地址传过去，此时在函数内求数组的元素个数，就会报错。
    int i = 0;
    bubbling(arr,sz);
    for( i = 0 ; i<sz ; i++)
    {
        printf("%d ",i);
    }   
    return 0;
} */


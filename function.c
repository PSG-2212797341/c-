#include<stdio.h>
#include<math.h>                    //引用自己写的头文件要用引号引起来。
// 一、函数的分类：
// 1、库函数：（学习可以参考下面网站）：系统自带的函数，引用时需要头文件。
// C语言手册：https://zh.cppreference.com
// C语言文档：https://cplusplus.com/doc/tutorial/introduction/

// 2、自定义函数：
// 例如：写一个函数可以用来交换两个整形的值。
/* void change(int x,int y)                                //如果函数没有返回值那么函数名前加上void；如果有返回值，返回值是什么类型就在函数名前设置相同的类型。
{                                                       //因为定义一个变量后会在内存中找到一个地方储存它，并且它自己有独立的地址，所以上面定义的x\y，下面定义的a\b，都有自己独立的地址，虽然a\b的值是传过来给x\y。但是地址并没有过来，所以在x\y这里值是交换过，但是值只会保存在x\y的地址中。而非a\b。所以下面a\b的值不会改变。
    int tmp = 0;
    tmp = x;
    x = y;
    y = tmp;
}

void change2(int* x,int* y)                             //  int main()
{                                                       //  {
    int tmp = 0;                                        //    int a = 0;            
    tmp = *x;                                           //    int* pa =&a;          将a的地址取出来放在的指针变量pa里面
    *x = *y;                                            //    *pa = 20;             *pa：表示通过a的地址找到a这个值。
    *y = tmp;                                           //    return 0; 
}                                                       //  }   

int main()
{
    int a = 10;
    int b = 20;
    printf("a = %d b = %d\n",a,b);
    change(a,b);                                       
    printf("函数change:  a = %d b = %d\n",a,b);                      //此时会发现a、b的值并没有发生改变。
    change2(&a,&b);                                       
    printf("函数change2:  a = %d b = %d\n",a,b);                     //此时会发现a、b的值发生改变。
    return 0;
} */

// 二、函数参数：
// 1、实际参数（实参）：真实传给函数的参数，无论实参是什么类型的值，在函数调用时都必须要有确定的值，便于传给形参。
// 2、形式参数（形参）：函数名后括号里面的变量，形式参数只有在被使用的时候才会被分配空间，使用后就会被销毁。所以形参只能在函数内有效。

//三、函数调用：
// 1、传值调用：当实参传给形参的时候，形参是实参的一份临时拷贝，对形参的修改是不会改变实参的。
// 2、传地址调用：是吧函数外部创建变量的内部地址传递给函数参数的一种调用函数的方式，可以让函数和函数外边的数据联系起来，也就是函数内部可以直接操作函数外部的变量。

// 一、二、三、举个栗子：
// 1、打印100-200之间所有的素数。
// 1、2的方法：把里面的一层循环写成一个函数就可以。
/* int if_pri_num(int n)
{
    int j = 0;
    for(j = 2;j <= sqrt(n);j++)
    {
        if(n%j == 0)
        {
            return 0;
            break;
        }
        return 1;
    }
}

int main()
{
    int i = 0;
    for(i = 100; i <= 200; i++)
    {
        if(if_pri_num(i) == 1)
        {
            printf("%d ",i);
        }
    }
    return 0;
} */

// 2、打印1000-2000年中的闰年。
/* int is_leap_year(int n)
{
    if((n%4 == 0 && n%100 !=0) || (n%400 == 0))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

int main()
{
    int year = 0;
    int num = 0;
    for(year = 1000; year <=2000; year++)
    {
        if(is_leap_year(year) == 1)
        {
            printf("%d ",year);
            num++;
        }
    }
    printf("%d",num);
    return 0;
} */

// 3、使用二分查找的方法在一个有序的数组中查找具体的某个数字。
/* int bin_sea(int arr[],int k,int sz)
{
    int left = 0;
    int right = sz - 1;
    while (left <= right)
    {
        int mid = (left+right)/2;
        if(arr[mid]  < k)
        {
            left = mid + 1;
        }
        else if(arr[mid] > k)
        {
            right = mid - 1;
        }
        else
        {
            return mid;
        }
    }
    return 1;
}

int main()
{
    int arr[] = {1,2,3,4,5,6,7,8,9,10};
    int sz = sizeof(arr)/sizeof(arr[0]);            //求数组的元素个数不能在函数里面去求，如果在函数里面求的话：因为下面传上来的是数组的第一个元素的地址，所以需要指针来接收，那么这里的arr[]是一个指针变量，那么通过sizeof()计算指针的大小得到要么4/8（取决于是w32/w64）。而后面的sizeof(arr[0])：得到的是一个int型的大小为4；随意结果并不是元素的个数。
    int k = 7;
    int c = bin_sea(arr,k,sz);                      //数组传参的时候并不会所有的元素地址都会传过去。只是会把数组的第一个元素地址传过去。
    if (c == 1)
    {
        printf("找不到这个元素");
    }
    else
    {
        printf("找到了，这个数字的下标为：%d",c);
    }
    return 0;
} */

// 4、写一个函数，每次调用一下这个函数会使num+1。
/* void add(int* p)
{
    (*p)++;                     //++的优先级非常高，所以用括号扩起来，不然++会作用在p上。
}

int main()
{
    int num = 0;
    add(&num);                          //因为函数可以改变函数外的变量，所以采用传地址的方法。
    printf("num = %d\n",num);
    add(&num);
    printf("num = %d\n",num);
    add(&num);
    printf("num = %d\n",num);
    return 0;
} */

// 四、函数的链式访问。
/* int main()
{
    printf("%d",printf("%d",printf("%d",43)));             //print()函数：返回值是打印字符的个数，为整形。
// →  printf("%d",printf("%d",2));                        //首先最里面的会打印  43  两个数字，打印字符个数为2，那么返回值也会为2.
// →  printf("%d",1);                                     //然后中间的会打印  2  一个数字，打印字符个数为1，那么返回值也会为1.
// →  1                                                   //然后最后的会打印  1  一个数字，打印字符个数为1，那么返回值也会为1.
// →  打印值为：4321
    return 0;
} */

// 五、函数的声明和定义：（类似于前端开发中的引用自己写的css文件/JS文件的路径）和（自己写的css文件/JS文件）。
// 1、声明：告诉编译器有一个函数叫什么，参数是什么，返回类型是什么，但存在不存在，声明不管；并且函数声明出现在函数的使用前，要满足先声明后使用；函数的声明需要放在头文件中。
// 2、定义：是指函数的具体实现，交代函数的功能实现。
// 函数声明：下面这种写法类似前端开发中的行内JS。
/* int add(int x,int y);

int main()
{
    int a = 10;
    int b = 20;
    int sum = 0;
// 函数调用：
    sum = add(a,b);
    printf("sum = %d",sum);
    return 0;
}

// 函数定义：
int add(int x,int y)
{
    int z = z = x + y;
    return z;
} */

// 六、函数递归：
// 1、递归的定义：程序调用自身的编程技巧程为递归，作为一种算法在程序设计语言中广泛应用，一个函数/函数在定义的过程中有直接/间接调用自身的一种方法，通常把一个大型复杂的问题层层转化为一个与原问题相似/规模较小的问题来求解。
// 2、条件：存在限制条件，当满足这个限制条件时，递归便不再继续；/每次递归调用后会越来越接近这个限制条件。
// 例如：最简单的递归。
/* int main()
{
    printf("hehe");                     //每次函数的调用都会向内存申请空间，而内存的空间又会分成：栈区（存放：局部变量、函数、形参）、堆区（存放：动态开辟的内存）、静态区（存放：全局变量、static修饰的变量）;
    main();                             //而这段代码会一直调用一直调用，那么也会一直向栈区申请空间，直到栈区没有空间后，就会（停下来）报错 -- 栈溢出。
    return 0;                           //这段代码运行并不会一直打印hehe，而是最终会停下来，会出现栈溢出的情况。
} */

// 例1：输入一个整型值（无符号），按照顺序打印它的每一位（例如：输入1234，打印：1 2 3 4。）
// 方法：如果想按顺序打印1234的话：1234可以先打印123，再打印4 → 123可以先打印12，再打印3 → 12可以先打印1，再打印2。
//                                                  得到一个数的最后一位可以采取取余数（%10）。
//                                          得到一个数的前几位可以采取取商（/10）。
/* void print(int n)
{
    if(n > 9)                           //如果是一位数的话直接打印就可以了。
    {
        print(n/10);                    //每次都把余数去掉。
    }
    printf("%d ",n%10);                 //每次只会打印一个数字。
}

int main()
{
    int num = 0;
    scanf("%d",&num);
    print(num);
    return 0;
} */

//例2：写一个函数，用来计算字符串的长度。
// 方法：字符串的长度就是：从第一个元素开始数，一直到把 \0 之前的那个字符数完为止，那么也就是可以用 \0 为标志，
//创建变量：
/* int my_str(char* str)
{
    int num = 0;
    while(*str != '\0')                 //''引起的是一个元素，""引起的是一个字符串。
    {
        num++;                          
        str++;                          //每次通过比对后如果没有找到 '0' 的话就会继续往后面找，直到找到为止
    }
    return num;
}

//不创建变量：
int my_str(char* str)
{
    if(*str != '\0')
    {
        return 1 + my_str(arr+1);          //这里求字符串长度就是从第一个元素开始，判断一下是不是'\0'，如果不是，那么就等于1 + 剩下的字符串的长度，直到  '\0' 停止。
    }
    else
    {
        return 0;
    }
}

int main()
{
    char arr[] = "bit";
    int len = my_str(arr);
    printf("len = %d",len);
    return 0;
} */

//例3：计算n!（递归与迭代）
//用for循环写函数
/* int add(int n)
{
    int i = 0;
    int j = 1;
    for(i = 1; i <= n; i++)
    {
        j *=i;
    }
    return j;
} */

//用递归的方法写函数：
// 方法：在数学里面定义n！：如果n = 1 → n! = 1；如果n >= 2 → n! = n * (n - 1)!。 
/* int add2(int n)
{
    if(n == 1)
    {
        return 1;
    }
    else
    {
        return n * add2(n - 1);
    }
}

int main()
{
    int n = 0;
    int ret = 0;
    scanf("%d",&n);
    ret = add2(n);
    printf("ret = %d",ret);
    return 0;
} */

// 例4：写一个函数来表示斐波那契数列的第n个数（n = 1 → 第一个数等于1；n >= 2 → 第n个数 = （n - 1）+（n - 2））。
// 用递归的方式写：（这里效率会很低）
/* int add3(int n)
{
    if(n <= 2)                      //这里判断的条件不能给 n == 1 因为当等于n = 2时下面不知道add3(0)的值为多少，导致程序不会运行。
    {
        return 1;
    }
    else
    {
        return add3(n-1) + add3(n-2);       //这里计算起来会非常慢，需要几分钟的时间才能算出来，因为从后往前算的话（比如第50个），需要知道第49、48个的值，而这些又不知道，有需要知道第48/47、47/46的值...会一直到可以计算出来为止，所以之间重复使用的数字按照指数式的增长，所以这个地方用递归的方式不是很好。
    }
} */

// 用循环的方式写：
// 方法：既然从后往前算很麻烦，那么就从前往后算吧，通过数列可以发现，数列中从第三个数开始都是前面两个数的和，所以可以从第三个数开始把第三、四、五个的数作为一组，计算出第六个数，然后把第四、五、六个的数作为一组，算出第七个数....一直重复下去，直到算到自己想需要的那个数位置。
/* int add3(int n)
{
    int a = 1;
    int b = 1;
    int c = 1;          //初始值为1是为了避免当 n为1/2 的情况时，c的值会出现错误。
    while (n > 2)
    {
        c = a + b;
        a = b;
        b = c;          //这两处赋值不能改变位置，否则就会a、b相等了。
        n--;            //循环一次就减一次。
    }
     return c;
}

int main()
{
    int n = 0;
    int ret2 = 0;
    scanf("%d",&n);
    ret2 = add3(n);
    printf("ret2 = %d",ret2);
    return 0;
} */

// 递归经典例题1：汉诺塔问题：
// 题目：给定三根柱子，记为a、b、c，其中 a 柱子上有 n 个盘子，从上到下编号为 1 - n ，且上面的盘子一定比下面的盘子小。那么请给出从 a 柱上的盘子经由 b 柱移动到 c 柱的具体移动方法。
// 规则：
// 1、移动时一次只能移动一个盘子
// ​2、大的盘子不能压在小盘子上
// 方法1：（递归） → → →    因为一共有n个盘子，从最下面那个盘子（n）的角度看：如果我想从移动到 c 柱，那我就需要我上面的 1 - n-1个盘子先移动去 b 柱，我自己才能去 c 柱，然后我就可以不动，你们怎么从 a → b 就怎么从 b → c 这样任务就完成了。
//                                          从最下面倒数第一个盘子（n-1）的角度看：如果我想从移动到 c 柱，那我就需要我上面的 1 - n-2个盘子先移动去 b 柱，我自己才能去 c 柱，然后我就可以不动，你们怎么从 a → b 就怎么从 b → c 这样任务就完成了。
//                                          ...
//                                          一直到只有一个盘子的时候，问题就解决了。
/* void move(char a, char b)
{
    printf("%c → %c\n",a,b);
}

void Tower(int n, char x, char y, char z)
{
    if(n == 1 )
    {
        move(x,z);                      //把单独的一个盘子直接放到 z 柱再说。
    }
    else
    {
        Tower(n-1,x,z,y);               //把 n-1个盘子从 x 柱经过 z 柱到达 y 柱。
        move(x,z);                      //把剩下的那个盘子直接放到 z 柱再说。
        Tower(n-1,y,x,z);               //把 n-1个盘子从 y 柱经过 x 柱到达 z 柱。
    }
}

int main()
{
    int n = 0;
    printf("请输入你想要几层汉诺塔的解法：");
    scanf("%d",&n);
    Tower(n,'a','b','c');
    return 0;
} */

// 递归经典例题2：青蛙跳台阶（满足斐波那契数列,只不过青蛙的前两次分别为1/2，而数列的前两项为1/1）
// 题目：一只青蛙一次可以跳一节台阶/两节台阶，求跳n阶台阶有多少种求法。
/* int forg(int i)
{
    int a = 1;
    int b = 2   ;
    int c = 1;
    if (i == 1)
    {
        return a;
    }
    else if (i == 2)
    {
        return b;
    }
    else
    {
        while(i > 2)
        {
            c = a + b;
            a = b;
            b = c; 
            i--;  
        }
        return c;
    }
}

int main()
{
    int n = 0;
    int ret = 0;
    printf("请输入你想知道青蛙跳第几阶台阶的情况：");
    scanf("%d",&n);
    ret = forg(n);
    printf("ret = %d",ret);
} */